From 4e7d87e3d532770d3d315a8be7ae751ae73a60c5 Mon Sep 17 00:00:00 2001
From: Carlos Alberto Petry <carlos.petry@ic.unicamp.br>
Date: Thu, 27 Aug 2015 21:46:20 -0300
Subject: [PATCH 1/7] Chisel (on latest version) implementation: SystemC
 Decoupled and Template file (need to be tested).

---
 src/main/resources/template_cpp.txt |  27 +++++++++
 src/main/resources/template_h.txt   |  58 ++++++++++++++++++++
 src/main/scala/SCWrapper.scala      | 106 +++++++++++++++++++++---------------
 src/main/scala/SysC.scala           |  34 +++++++-----
 4 files changed, 169 insertions(+), 56 deletions(-)
 create mode 100644 src/main/resources/template_cpp.txt
 create mode 100644 src/main/resources/template_h.txt

diff --git a/src/main/resources/template_cpp.txt b/src/main/resources/template_cpp.txt
new file mode 100644
index 0000000..1996287
--- /dev/null
+++ b/src/main/resources/template_cpp.txt
@@ -0,0 +1,27 @@
+#include "{!name!}.h"
+
+void {!name!}::input_thread(void){
+  while(true){
+//    wait(data_written_event);
+    {!input_thread!}
+    {!set_valid_ready!}
+    //Clock Lo
+    c->clock_lo(reset);
+    wait(Step);
+//    data_read_event.notify(SC_ZERO_TIME);
+  }
+}
+
+void {!name!}::output_thread(void){
+//  data_written_event.notify(SC_ZERO_TIME);
+  while(true){
+    wait(data_read_event);
+    {!output_thread!}
+    {!reset_valid_ready!}
+    //Clock Hi
+    c->clock_hi(reset);
+    wait(Step);
+//    data_written_event.notify(SC_ZERO_TIME);
+  }
+}
+
diff --git a/src/main/resources/template_h.txt b/src/main/resources/template_h.txt
new file mode 100644
index 0000000..f1f4644
--- /dev/null
+++ b/src/main/resources/template_h.txt
@@ -0,0 +1,58 @@
+#ifndef __{!name!}__
+#define __{!name!}__
+
+#include <systemc.h>
+#include "{!header_file!}"
+
+// ========================================
+// dat_t needs to have this operator defined, so that
+// I'm allowed to use it with System C.
+// But be warned: I don't quite know what I
+// am doing.
+// ========================================
+template <int w>
+inline ostream& operator << (ostream& os, const dat_t<w>& arg){
+  return os;
+}
+
+SC_MODULE({!name!}){
+  {!component_type!}* c;
+
+  // in ports
+  {!input_ports!}
+  // out ports
+  {!output_ports!}
+  SC_HAS_PROCESS({!name!});
+  {!name!}(sc_module_name a_name, sc_time _step)
+  : sc_module(a_name), Step(_step)
+  {!sctor_list!}
+  {
+    // Initialize Component, Clock in RESET
+    c = new {!component_type!}();
+    c->init();
+    Step = Step/2;
+
+    // Clock Initialization? Don't understand what this is for. Copied from emulator.
+    for(int i = 0; i < 5; i++) {
+      dat_t<1> reset = LIT<1>(1);
+      c->clock_lo(reset);
+      c->clock_hi(reset);
+    }
+
+    //Register Thread
+    SC_THREAD(input_thread);
+//    {!sensitive_list!}
+    SC_THREAD(output_thread);
+  }
+
+  void input_thread(void);
+  void output_thread(void);
+
+//  sc_event data_read_event;
+//  sc_event data_written_event;
+  dat_t<1> reset = LIT<1>(0);
+  dat_t<1> set = LIT<1>(1);
+  sc_time Step;
+};
+
+#endif  //__{!name!}__
diff --git a/src/main/scala/SCWrapper.scala b/src/main/scala/SCWrapper.scala
index d1d659d..2d58441 100644
--- a/src/main/scala/SCWrapper.scala
+++ b/src/main/scala/SCWrapper.scala
@@ -54,21 +54,21 @@ object SCWrapper {
 
   def example_component_def(): ComponentDef = {
     val cdef = new ComponentDef("GCD_t", "GCD")
-    cdef.entries += new CEntry("a", true, "dat_t<1>", "GCD__io_a", "GCD__io_r1", "GCD__io_v1")
-    cdef.entries += new CEntry("z", false, "dat_t<1>", "GCD__io_z", "GCD__io_rz", "GCD__io_vz")
+    cdef.entries += new CEntry("a", true, "dat_t<1>", 1, "GCD__io_a", "GCD__io_r1", "GCD__io_v1")
+    cdef.entries += new CEntry("z", false, "dat_t<1>", 1, "GCD__io_z", "GCD__io_rz", "GCD__io_vz")
     cdef
   }
 
   def example_component_def2(): ComponentDef = {
     val cdef = new ComponentDef("AddFilter_t", "AddFilter")
-    cdef.entries += new CEntry("a", true, "dat_t<16>", "AddFilter__io_a", "AddFilter__io_ar", "AddFilter__io_av")
-    cdef.entries += new CEntry("b", false, "dat_t<16>", "AddFilter__io_b", "AddFilter__io_br", "AddFilter__io_bv")
+    cdef.entries += new CEntry("a", true, "dat_t<16>", 16, "AddFilter__io_a", "AddFilter__io_ar", "AddFilter__io_av")
+    cdef.entries += new CEntry("b", false, "dat_t<16>", 16, "AddFilter__io_b", "AddFilter__io_br", "AddFilter__io_bv")
     cdef
   }
 
-  def genwrapper(c: ComponentDef, filename:  String) {
+  def genwrapper(c: ComponentDef, filename:  String, templatefile: String) {
     //Read in template
-    val template = read_resource("template.txt")
+    val template = read_resource(templatefile)
 
     //Generate replacements
     val replacements = generate_replacements(c)
@@ -81,9 +81,9 @@ object SCWrapper {
     System.out.println(filled)
   }
 
-  def genwrapper(c: ComponentDef, filewriter: java.io.FileWriter){
+  def genwrapper(c: ComponentDef, filewriter: java.io.FileWriter, templatefile: String){
     //Read in template
-    val template = read_resource("template.txt")
+    val template = read_resource(templatefile)
 
     //Generate replacements
     val replacements = generate_replacements(c)
@@ -106,62 +106,80 @@ object SCWrapper {
     replacements += (("name", "SCWrapped" + c.name))
     replacements += (("component_type", c.ctype))
 
-    //I/O Fifos
+    //I/O Ports
     /*begin*/{
-      var input_fifos = ""
-      var output_fifos = ""
+      var input_ports = ""
+      var output_ports = ""
+	  var sctor_list = ""
+      var input_thread = ""
+      var output_thread = ""
+
       for( e <- c.entries) {
-        val decl = "sc_fifo<%s >* %s;\n  ".format(e.ctype, e.name)
+        val decl_in  = "sc_in<sc_uint<%s> > %s__io_%s;\n  ".format(e.cwidth, c.name, e.name)
+        val decl_out = "sc_out<sc_uint<%s> > %s__io_%s;\n  ".format(e.cwidth, c.name, e.name)
+        val thread_in = "c->%s__io_%s = LIT<%s>(%s__io_%s->read());\n    ".format(c.name, e.name, e.cwidth, c.name, e.name)
+        val thread_out = "%s__io_%s->write(c->%s__io_%s.to_ulong());\n    ".format(c.name, e.name, c.name, e.name)
+        //val decl = "sc_fifo<%s >* %s;\n  ".format(e.ctype, e.name)
         if(e.is_input) {
-          input_fifos += decl
+          input_ports += decl_in
+          sctor_list += ", %s__io_%s(\"%s\")".format(c.name, e.name, e.name)
+          //sensitive_list += " << %s__io_%s".format(c.name, e.name)
+          input_thread += thread_in
         } else {
-          output_fifos += decl
+          output_ports += decl_out
+          sctor_list += ", %s__io_%s(\"%s\")".format(c.name, e.name, e.name)
+          output_thread += thread_out
         }
       }
-      replacements += (("input_fifos", input_fifos))
-      replacements += (("output_fifos", output_fifos))
+      replacements += (("input_ports", input_ports))
+      replacements += (("output_ports", output_ports))
+      replacements += (("sctor_list", sctor_list))
+      //sensitive_list += ";"
+      //replacements += (("sensitive_list", sensitive_list))
+      replacements += (("input_thread", input_thread))
+      replacements += (("output_thread", output_thread))
     }
 
-    /*Initialize output fifos*/{
-      //Pull out output fifos
-      val fifos = ArrayBuffer[CEntry]();
+    /*Initialize output ports*/{
+      //Pull out output ports
+      val ports = ArrayBuffer[CEntry]();
       for(e <- c.entries) {
         if(!e.is_input) {
-          fifos += e;
+          ports += e;
         }
       }
       //Initialize
       var init = "";
-      for( i <- 0 until fifos.size) {
-        init += "%s = new sc_fifo<%s >(1);\n  ".format(fifos(i).name, fifos(i).ctype)
+      for( i <- 0 until ports.size) {
+        init += "%s = new sc_fifo**???**<%s >(1);\n  ".format(ports(i).name, ports(i).ctype)
       }
       replacements += (("init_output_fifos", init))
     }
 
     /*Check input queues*/{
-      //Pull out input fifos
+      //Pull out input ports
       val dvar = ArrayBuffer[String]()
       val fvar = ArrayBuffer[String]()
-      val fifos = ArrayBuffer[CEntry]()
+      val ports = ArrayBuffer[CEntry]()
       for( e <- c.entries) {
         if(e.is_input) {
           dvar += genvar("dat")
           fvar += genvar("filled")
-          fifos += e
+          ports += e
         }
       }
       //Initialize
       var init = ""
       var fill = ""
       var check = ""
-      for( i <- 0 until fifos.size) {
-        val ctype = fifos(i).ctype
+      for( i <- 0 until ports.size) {
+        val ctype = ports(i).ctype
         val data = dvar(i)
         val filled = fvar(i)
-        val in = fifos(i).name
-        val in_data = fifos(i).data
-        val ready = fifos(i).ready
-        val valid = fifos(i).valid
+        val in = ports(i).name
+        val in_data = ports(i).data
+        val ready = ports(i).ready
+        val valid = ports(i).valid
         init += "%s %s;\n    ".format(ctype, data)
         init += "int %s = 0;\n    ".format(filled)
         fill += "if(!%s){%s = %s->nb_read(%s);}\n      "format(filled, filled, in, data)
@@ -183,22 +201,22 @@ object SCWrapper {
     }
 
     /*Check Output Queues*/{
-      //Pull out output fifos
-      val fifos = ArrayBuffer[CEntry]()
+      //Pull out output ports
+      val ports = ArrayBuffer[CEntry]()
           for (e <- c.entries) {
             if(!e.is_input) {
-              fifos += e
+              ports += e
             }
           }
       //Check
       var check = ""
       var valid_output = "";
-      for(i <- 0 until fifos.size) {
-        val ctype = fifos(i).ctype
-        val valid = fifos(i).valid
-        val data = fifos(i).data
-        val ready = fifos(i).ready
-        val out = fifos(i).name
+      for(i <- 0 until ports.size) {
+        val ctype = ports(i).ctype
+        val valid = ports(i).valid
+        val data = ports(i).data
+        val ready = ports(i).ready
+        val out = ports(i).name
         check += "c->%s = LIT<1>(%s->num_free() > 0);\n      "format(ready, out)
         // Is this a structured data-type?
         if (ctype == data) {
@@ -220,11 +238,11 @@ object SCWrapper {
 
     // If we have structured FIFO elements, we need to generate the struct definitions
     //  and the ostream "<<" definition to keep SystemC happy.
-    val ostream_lsh = ArrayBuffer[String]()
+/*    val ostream_lsh = ArrayBuffer[String]()
     for((name, struct) <- c.structs) {
       ostream_lsh += struct.toString + "inline ostream& operator << (ostream& os, const %s& arg){  return os; }\n".format(name)
     }
-    replacements += (("ostream_lsh", ostream_lsh.mkString("\n")))
+    replacements += (("ostream_lsh", ostream_lsh.mkString("\n")))	*/
     replacements
   }
 
@@ -309,10 +327,11 @@ object SCWrapper {
   }
 }
 
-class CEntry(a_name: String, input: Boolean, a_type: String, a_data: String, a_ready: String, a_valid: String) {
+class CEntry(a_name: String, input: Boolean, a_type: String, a_width: Int, a_data: String, a_ready: String, a_valid: String) {
    val name = a_name
    val is_input = input
    val ctype = a_type
+   val cwidth = a_width
    val data = a_data
    val ready = a_ready
    val valid = a_valid
@@ -321,6 +340,7 @@ class CEntry(a_name: String, input: Boolean, a_type: String, a_data: String, a_r
      name + " " +
      is_input + " " +
      ctype + " " +
+     cwidth + " " +
      data + " " +
      ready + " " +
      valid
diff --git a/src/main/scala/SysC.scala b/src/main/scala/SysC.scala
index 566a3cf..73c17e1 100644
--- a/src/main/scala/SysC.scala
+++ b/src/main/scala/SysC.scala
@@ -30,9 +30,7 @@
 
 package Chisel
 
-/** If we have structured/aggregate types as top-level ports, we define suitable structures
-  * for encapsulating their components, in order to treat them as sc_fifo elements.
-  */
+
 class SysCBackend extends CppBackend {
    override def elaborate(c: Module): Unit = {
       super.elaborate(c)
@@ -51,29 +49,35 @@ class SysCBackend extends CppBackend {
             case bits: Bits => {
               val is_input = bits.dir == INPUT
               val vtype = "dat_t<" + bits.width + ">" // direct use of width here?
-              val entry = new CEntry(name, is_input, vtype, bits.name, delt.ready.name, delt.valid.name)
+              val entry = new CEntry(name, is_input, vtype, bits.width, bits.name, delt.ready.name, delt.valid.name)
               cdef.entries += (entry)
             }
             case aggregate: Aggregate => {
               // Collect all the inputs and outputs.
               val inputs = aggregate.flatten.filter(_._2.dir == INPUT)
               if (inputs.length > 0) {
-                val aName = "cs_" + aggregate.name + "_i"
-                cdef.structs(aName)= new CStruct(aName, inputs)
-                val entry = new CEntry(name, true, aName, aName, delt.ready.name, delt.valid.name)
+                val aName = "dat_t<" + aggregate.width + ">"		//"cs_" + aggregate.name + "_i"
+                //cdef.structs(aName)= new CStruct(aName, inputs)
+                val entry = new CEntry(name, true, aName, aggregate.width, aggregate.name, delt.ready.name, delt.valid.name)
                 cdef.entries += (entry)
               }
               val outputs = aggregate.flatten.filter(_._2.dir == OUTPUT)
               if (outputs.length > 0) {
-                val aName = "cs_" + aggregate.name + "_o"
-                cdef.structs(aName) = new CStruct(aName, outputs)
-                val entry = new CEntry(name, false, aName, aName, delt.ready.name, delt.valid.name)
+                val aName = "dat_t<" + aggregate.width + ">"		//"cs_" + aggregate.name + "_o"
+                //cdef.structs(aName) = new CStruct(aName, outputs)
+                val entry = new CEntry(name, false, aName, aggregate.width, aggregate.name, delt.ready.name, delt.valid.name)
                 cdef.entries += (entry)
               }
             }
             case _ => badElements(name) = elt
           }
         }
+        case bits: Bits => {
+          val is_input = bits.dir == INPUT
+          val vtype = "dat_t<" + bits.width + ">" // direct use of width here?
+          val entry = new CEntry(name, is_input, vtype, bits.width, bits.name, "ready", "valid")
+          cdef.entries += (entry)
+        }
         case _ => badElements(name) = elt
       }
     }
@@ -93,9 +97,13 @@ class SysCBackend extends CppBackend {
       //Print out the component definition.
       println(cdef)
 
-      //Generate the file.
-      val out_p = createOutputFile("SCWrapped" + c.name + ".cpp");
-      SCWrapper.genwrapper(cdef, out_p)
+      //Generate SCWrapped files
+      val out_h = createOutputFile("SCWrapped" + c.name + ".h");
+      val template_h = "template_h.txt"
+      SCWrapper.genwrapper(cdef, out_h, template_h)
+      val out_cpp = createOutputFile("SCWrapped" + c.name + ".cpp");
+      val template_cpp = "template_cpp.txt"
+      SCWrapper.genwrapper(cdef, out_cpp, template_cpp)
     }
   }
 }
-- 
2.1.0

